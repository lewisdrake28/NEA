0001: <!--//////////////-->
0002: <!-- FINAL.csproj -->
0003: <!--//////////////-->
0004: <Project Sdk="Microsoft.NET.Sdk">
0005:   <PropertyGroup>
0006:     <OutputType>Exe</OutputType>
0007:     <TargetFramework>net6.0</TargetFramework>
0008:     <ImplicitUsings>enable</ImplicitUsings>
0009:     <Nullable>enable</Nullable>
0010:   </PropertyGroup>
0011:   <ItemGroup>
0012:     <PackageReference Include="Newtonsoft.Json" Version="13.0.1" />
0013:     <PackageReference Include="Terminal.Gui" Version="1.*" />
0014:   </ItemGroup>
0015: </Project>
0016: //////////////////
0017: // Utilities.cs //
0018: //////////////////
0019: // install dependencies
0020: using System.Text;
0021: using System.Net;
0022: using Newtonsoft.Json;
0023: // suppress warnings
0024: # pragma warning disable
0025: namespace Utilities
0026: {
0027:     ////////////
0028:     // BKTree //
0029:     ////////////
0030:     class BkTree
0031:     {
0032:         protected static LevenshteinDistance leven = new LevenshteinDistance();
0033:         // each node has its own word, and a list of connections to store edge weights to children
0034:         public static Dictionary<string, List<Connection>> tree = new Dictionary<string, List<Connection>>();
0035:         protected static string[] words = File.ReadAllLines("Resources/TrueWords.txt");
0036:         protected static int[] weights = new int[words.Length];
0037:         protected string root;
0038:         protected List<string> visitedWords = new List<string>();
0039:         public BkTree(string rootIn)
0040:         {
0041:             tree.Clear();
0042:             root = rootIn;
0043:             weights = leven.CalculateAll(rootIn, words);
0044:             // create the tree where every word is a node
0045:             for (int a = 0; a < words.Length; a++)
0046:             {
0047:                 if (tree.Count == 0)
0048:                 {
0049:                     CreateRoot(rootIn);
0050:                 }
0051:                 else
0052:                 {
0053:                     if (words[a] != root)
0054:                     {
0055:                         AddNode(words, weights, a);
0056:                     }
0057:                 }
0058:             }
0059:         }
0060:         protected void CreateRoot(string word)
0061:         {
0062:             Connection thisConnection = new Connection();
0063:             thisConnection.word = word;
0064:             // weight from root -> root = i (therefore 0)
0065:             thisConnection.weight = 0;
0066:             List<Connection> connections = new List<Connection>();
0067:             connections.Add(thisConnection);
0068:             tree.Add(word, connections);
0069:         }
0070:         public void AddNode(string[] words, int[] weights, int index)
0071:         {
0072:             Connection thisConnection = new Connection();
0073:             thisConnection.word = words[index];
0074:             thisConnection.weight = weights[index];
0075:             CreateNode(thisConnection.word, root, thisConnection.weight);
0076:         }
0077:         protected void CreateNode(string word, string parent, int weight)
0078:         {
0079:             // checks if an edge from the root node already exists with the same weight
0080:             // if it doesn't, then create node as nornmal from the root
0081:             // if it does, then use that node (that has the same weight) as the new parent
0082:             // due to the nature of BK-trees every edge from a parent must have a distinct weight
0083:             string? exists = CheckEdges(parent, weight);
0084:             if (exists is not null)
0085:             {
0086:                 // but weight from the parent might be different to the weight from the node, so recalculate
0087:                 int newWeight = leven.Calculate(parent, word);
0088:                 CreateNode(word, exists, newWeight);
0089:             }
0090:             else
0091:             {
0092:                 Connection thisConnection = new Connection();
0093:                 thisConnection.word = word;
0094:                 thisConnection.weight = weight;
0095:                 if (!tree.ContainsKey(thisConnection.word))
0096:                 {
0097:                     tree.Add(thisConnection.word, new List<Connection>());
0098:                     tree[parent].Add(thisConnection);
0099:                 }
0100:             }
0101:         }
0102:         // search each edge from a specified parent to see if a particular weight already exists
0103:         protected string CheckEdges(string word, int weight)
0104:         {
0105:             List<int> edges = new List<int>();
0106:             for (int a = 0; a < tree[word].Count; a++)
0107:             {
0108:                 edges.Add(tree[word][a].weight);
0109:             }
0110:             for (int a = 0; a < edges.Count; a++)
0111:             {
0112:                 if (edges[a] == weight)
0113:                 {
0114:                     return tree[word][a].word;
0115:                 }
0116:             }
0117:             return null;
0118:         }
0119:         public void ClearTree()
0120:         {
0121:             for (int a = 0; a < tree.Count; a++)
0122:             {
0123:                 tree.Remove(words[a]);
0124:             }
0125:             tree.Clear();
0126:         }
0127:         // input 1 when ReturnClosest is called in program
0128:         // public List<string> ReturnClosest(int maxWeight)
0129:         public string[] ReturnClosest(int maxWeight)
0130:         {
0131:             // used as a dummy to store the index of last word used as parent
0132:             Connection dummyConnection = new Connection();
0133:             dummyConnection.word = "";
0134:             dummyConnection.weight = 0;
0135:             string parent = FindParent(maxWeight);
0136:             List<Connection> closeWords = tree[parent];
0137:             while (closeWords.Count < 15)
0138:             {
0139:                 if (!(dummyConnection.weight < closeWords.Count))
0140:                 {
0141:                     break;
0142:                 }
0143:                 parent = closeWords[dummyConnection.weight].word;
0144:                 closeWords.AddRange(tree[parent]);
0145:                 dummyConnection.weight++;
0146:             }
0147:             string[] wordsOut = new string[closeWords.Count];
0148:             for (int a = 0; a < closeWords.Count; a++)
0149:             {
0150:                 wordsOut[a] = closeWords[a].word;
0151:             }
0152:             return wordsOut;
0153:         }
0154:         protected string FindParent(int maxWeight)
0155:         {
0156:             bool exists = false;
0157:             while (!exists)
0158:             {
0159:                 for (int a = 0; a < tree[root].Count; a++)
0160:                 {
0161:                     if (tree[root][a].weight < maxWeight && tree[root][a].word != root)
0162:                     {
0163:                         return tree[root][a].word;
0164:                     }
0165:                 }
0166:                 if (!exists)
0167:                 {
0168:                     maxWeight++;
0169:                 }
0170:             }
0171:             return null;
0172:         }
0173:     }
0174:     /////////////////
0175:     // BloomFilter //
0176:     /////////////////
0177:     class BloomFilter
0178:     {
0179:         protected int[] filter = new int[2682975];
0180:         // FIRST TIME USE
0181:         // 
0182:         // constructor used to reset all indexes in the filter to 0
0183:         // then setup the filter to the text file
0184:         public BloomFilter(int num)
0185:         {
0186:             for (int a = 0; a < filter.Length; a++)
0187:             {
0188:                 filter[a] = 0;
0189:             }
0190:             SetUp();
0191:         }
0192:         // reads the list of words from text file
0193:         // inserts each word into filter
0194:         // write the filter to a text file
0195:         public void SetUp()
0196:         {
0197:             string[] words = File.ReadAllLines("Resources/TrueWords.txt");
0198:             foreach (var a in words)
0199:             {
0200:                 Insert(a);
0201:             }
0202:             WriteFilter();
0203:         }
0204:         // write the filter to a text file
0205:         protected void WriteFilter()
0206:         {
0207:             string filename = "Resources/Filter.txt";
0208:             string[] stringArray = filter.Select(x => x.ToString()).ToArray();
0209:             string result = String.Concat(stringArray);
0210:             File.WriteAllText(filename, result);
0211:         }
0212:         // GENERAL USE
0213:         // 
0214:         // read the filter from a text file and store as an int array
0215:         public BloomFilter()
0216:         {
0217:             string filename = "Resources/Filter.txt";
0218:             string text = File.ReadAllText(filename);
0219:             for (uint a = 0; a < filter.Length; a++)
0220:             {
0221:                 filter[a] = text[(int)a] - 48;
0222:             }
0223:         }
0224:         public bool Lookup(string word)
0225:         {
0226:             // there are only two one letter words that are in the set - "a" and "i"
0227:             // however all one letter words return true, so check all one letter words
0228:             if (word.Length == 1)
0229:             {
0230:                 return (word == "a" || word == "i");
0231:             }
0232:             else
0233:             {
0234:                 // if all the indexes are 1, then the item may be in the set
0235:                 // if any of the indexes are 0, then the item is definitely not in the set
0236:                 if (filter[Hash1(word)] == 1 && filter[Hash2(word)] == 1 && filter[Hash3(word)] == 1 && filter[Hash4(word)] == 1 && filter[Hash5(word)] == 1 && filter[Hash6(word)] == 1 && filter[Hash7(word)] == 1 && filter[Hash8(word)] == 1 && filter[Hash9(word)] == 1 && filter[Hash10(word)] == 1)
0237:                 {
0238:                     return true;
0239:                 }
0240:                 // if any of the indexes are 0, then do a binary search to check the list of user-added words
0241:                 else
0242:                 {
0243:                     return BinarySearch(word);
0244:                 }
0245:             }
0246:         }
0247:         public bool BinarySearch(string target)
0248:         {
0249:             target = target.ToLower();
0250:             string[] words = File.ReadAllLines("Resources/AddedWords.txt");
0251:             int min = 0;
0252:             int max = words.Length;
0253:             int mid;
0254:             while (min < max)
0255:             {
0256:                 mid = (min + max) / 2;
0257:                 if (words[mid] == target)
0258:                 {
0259:                     return true;
0260:                 }
0261:                 else if (words[mid].CompareTo(target) < 0)
0262:                 {
0263:                     min = mid + 1;
0264:                 }
0265:                 else 
0266:                 {
0267:                     max = mid - 1;
0268:                 }
0269:             }
0270:             return false;
0271:         }
0272:         protected void Insert(string word)
0273:         {
0274:             filter[Hash1(word)] = 1;
0275:             filter[Hash2(word)] = 1;
0276:             filter[Hash3(word)] = 1;
0277:             filter[Hash4(word)] = 1;
0278:             filter[Hash5(word)] = 1;
0279:             filter[Hash6(word)] = 1;
0280:             filter[Hash7(word)] = 1;
0281:             filter[Hash8(word)] = 1;
0282:             filter[Hash9(word)] = 1;
0283:             filter[Hash10(word)] = 1;
0284:             WriteFilter();
0285:         }
0286:         // Pearson Hashing
0287:         protected uint Hash1(string word)
0288:         {
0289:             uint hash = 0;
0290:             byte[] bytes = Encoding.UTF8.GetBytes(word);
0291:             byte[] nums = { 114, 177, 249, 4, 222, 117, 190, 121, 130, 78, 53, 196, 255, 208, 5, 116, 221, 27, 144, 41, 252, 33, 170, 231, 62, 89, 235, 111, 174, 57, 105, 132, 204, 205, 151, 135, 90, 211, 37, 36, 66, 164, 40, 253, 108, 153, 98, 156, 67, 214, 35, 6, 38, 42, 162, 148, 28, 18, 254, 79, 61, 155, 3, 25, 184, 189, 152, 143, 84, 216, 87, 44, 75, 138, 191, 158, 243, 230, 1, 242, 91, 113, 26, 171, 245, 197, 22, 68, 187, 161, 218, 246, 97, 16, 234, 193, 73, 125, 101, 80, 226, 195, 139, 49, 9, 212, 224, 63, 72, 13, 100, 233, 104, 163, 207, 247, 137, 199, 136, 160, 203, 141, 250, 71, 200, 167, 129, 32, 19, 145, 238, 43, 142, 237, 198, 64, 76, 103, 182, 149, 2, 74, 107, 124, 88, 54, 157, 159, 51, 52, 102, 201, 7, 77, 180, 110, 109, 228, 85, 99, 11, 239, 169, 12, 8, 209, 165, 168, 248, 34, 82, 112, 140, 56, 120, 185, 55, 58, 31, 179, 47, 213, 86, 206, 194, 69, 127, 147, 123, 20, 219, 166, 29, 223, 220, 83, 70, 225, 188, 60, 21, 251, 240, 10, 119, 122, 23, 131, 96, 178, 227, 126, 173, 14, 17, 176, 192, 15, 46, 65, 215, 134, 232, 115, 106, 181, 175, 48, 202, 154, 150, 81, 50, 183, 39, 229, 92, 24, 217, 45, 172, 95, 128, 93, 133, 244, 210, 186, 118, 59, 30, 241, 146, 236, 94 };
0292:             foreach (var a in bytes)
0293:             {
0294:                 hash = nums[((hash ^ a) % (uint)nums.Length)];
0295:             }
0296:             hash %= (uint)filter.Length;
0297:             return hash;
0298:         }
0299:         // Hashing by cyclic polynomial (Buzhash)
0300:         protected uint Hash2(string word)
0301:         {
0302:             uint hash = 1;
0303:             foreach (char a in word)
0304:             {
0305:                 hash = CircularShift(hash) ^ CircularShift((byte)a) ^ CircularShift((uint)(byte)a + 1);
0306:             }
0307:             hash %= (uint)filter.Length;
0308:             return hash;
0309:         }
0310:         // Fowler-Noll-Vo (FNV-0) hash 
0311:         protected uint Hash3(string word)
0312:         {
0313:             uint hash = 0;
0314:             byte[] bytes = Encoding.UTF8.GetBytes(word);
0315:             foreach (var a in bytes)
0316:             {
0317:                 hash = (hash * 16777619) ^ a;
0318:             }
0319:             hash %= (uint)filter.Length;
0320:             return hash;
0321:         }
0322:         // dijb2
0323:         protected uint Hash4(string word)
0324:         {
0325:             // randomly generated number
0326:             uint hash = 5381;
0327:             byte[] bytes = Encoding.UTF8.GetBytes(word);
0328:             foreach (var b in bytes)
0329:             {
0330:                 hash = ((hash << 5) + hash) + 33;
0331:             }
0332:             hash %= (uint)filter.Length;
0333:             return hash;
0334:         }
0335:         // sdbm
0336:         protected uint Hash5(string word)
0337:         {
0338:             uint hash = 0;
0339:             byte[] bytes = Encoding.UTF8.GetBytes(word);
0340:             foreach (var a in bytes)
0341:             {
0342:                 hash = 65599 + (hash << 6) + (hash << 16) - hash;
0343:             }
0344:             hash %= (uint)filter.Length;
0345:             return hash;
0346:         }
0347:         // PJW hash function
0348:         protected uint Hash6(string word)
0349:         {
0350:             uint hash = 0;
0351:             uint bits = (sizeof(uint) * 8);
0352:             uint max = (uint)(0xFFFFFFFF) << (int)(bits - (bits / 8));
0353:             for (int a = 0; a < word.Length; a++)
0354:             {
0355:                 hash = hash << (int)(bits / 8) + word[a];
0356:                 if (max != 0)
0357:                 {
0358:                     hash = hash ^ (max >> (int)bits * 3 / 4) & (~max);
0359:                 }
0360:             }
0361:             hash %= (uint)filter.Length;
0362:             return hash;
0363:         }
0364:         // Fast-Hash
0365:         protected uint Hash7(string word)
0366:         {
0367:             // randomly generated number
0368:             uint a = unchecked((uint)0x880355f21e6d1965);
0369:             uint hash = 144 ^ ((uint)word.Length * a);
0370:             uint b = 0;
0371:             for (uint c = 0; c < word.Length; c++)
0372:             {
0373:                 hash = (hash ^ Mix(c)) * a;
0374:             }
0375:             int d = word.Length & 7;
0376:             d %= word.Length;
0377:             int e = (d - 1) * 8;
0378:             if (e < 0)
0379:             {
0380:                 e = 0;
0381:             }
0382:             b ^= (uint)word[d] << d;
0383:             hash ^= Mix(b) * a;
0384:             hash = Mix(hash);
0385:             hash %= (uint)filter.Length;
0386:             return (uint)hash;
0387:         }
0388:         // Rabin Fingerprint
0389:         protected uint Hash8(string word)
0390:         {
0391:             uint hash = word[0];
0392:             uint length = (uint)word.Length;
0393:             for (int a = 1; a < length; a++)
0394:             {
0395:                 hash += (uint)Math.Pow(word[a] * length, a);
0396:             }
0397:             hash %= (uint)filter.Length;
0398:             return hash;
0399:         }
0400:         // Fletcher-32
0401:         protected uint Hash9(string word)
0402:         {
0403:             uint a = 0;
0404:             uint b = 0;
0405:             for (int c = 0; c < word.Length; c++)
0406:             {
0407:                 a = (a + word[c] % (uint)0xffff);
0408:                 b = (a + b) % (uint)0xffff;
0409:             }
0410:             uint hash = (b << 16) | a;
0411:             hash %= (uint)filter.Length;
0412:             return hash;
0413:         }
0414:         // CRC32
0415:         protected uint Hash10(string word)
0416:         {
0417:             // randomly generated number
0418:             uint hash = 0xffffffff;
0419:             uint index;
0420:             byte[] nums = { 114, 177, 249, 4, 222, 117, 190, 121, 130, 78, 53, 196, 255, 208, 5, 116, 221, 27, 144, 41, 252, 33, 170, 231, 62, 89, 235, 111, 174, 57, 105, 132, 204, 205, 151, 135, 90, 211, 37, 36, 66, 164, 40, 253, 108, 153, 98, 156, 67, 214, 35, 6, 38, 42, 162, 148, 28, 18, 254, 79, 61, 155, 3, 25, 184, 189, 152, 143, 84, 216, 87, 44, 75, 138, 191, 158, 243, 230, 1, 242, 91, 113, 26, 171, 245, 197, 22, 68, 187, 161, 218, 246, 97, 16, 234, 193, 73, 125, 101, 80, 226, 195, 139, 49, 9, 212, 224, 63, 72, 13, 100, 233, 104, 163, 207, 247, 137, 199, 136, 160, 203, 141, 250, 71, 200, 167, 129, 32, 19, 145, 238, 43, 142, 237, 198, 64, 76, 103, 182, 149, 2, 74, 107, 124, 88, 54, 157, 159, 51, 52, 102, 201, 7, 77, 180, 110, 109, 228, 85, 99, 11, 239, 169, 12, 8, 209, 165, 168, 248, 34, 82, 112, 140, 56, 120, 185, 55, 58, 31, 179, 47, 213, 86, 206, 194, 69, 127, 147, 123, 20, 219, 166, 29, 223, 220, 83, 70, 225, 188, 60, 21, 251, 240, 10, 119, 122, 23, 131, 96, 178, 227, 126, 173, 14, 17, 176, 192, 15, 46, 65, 215, 134, 232, 115, 106, 181, 175, 48, 202, 154, 150, 81, 50, 183, 39, 229, 92, 24, 217, 45, 172, 95, 128, 93, 133, 244, 210, 186, 118, 59, 30, 241, 146, 236, 94, 0 };
0421:             byte[] bytes = Encoding.UTF8.GetBytes(word);
0422:             foreach (var b in bytes)
0423:             {
0424:                 index = ((hash ^ b) & 0xff) % (uint)nums.Length;
0425:                 hash = (hash >> 8) ^ nums[index];
0426:             }
0427:             hash ^= 0xffffffff;
0428:             hash %= (uint)filter.Length;
0429:             return hash;
0430:         }
0431:         // helpers
0432:         // for hash2
0433:         protected uint CircularShift(uint a)
0434:         {
0435:             uint b = a << 1 | a >> 31;
0436:             return b;
0437:         }
0438:         // for hash7
0439:         protected uint Mix(uint hash)
0440:         {
0441:             long a = (long)hash;
0442:             a ^= a >> 23;
0443:             // randomly generated number
0444:             a *= 0x2127599bf4325c37;
0445:             a ^= a >> 47;
0446:             hash = (uint)a;
0447:             return (uint)hash;
0448:         }
0449:     }
0450:     ////////////////
0451:     // Connection //
0452:     ////////////////
0453:     public struct Connection
0454:     {
0455:         // node
0456:         public string word;
0457:         // edge to parent
0458:         public int weight;
0459:     }
0460:     /////////////////
0461:     // Levenshtein //
0462:     /////////////////
0463:     class LevenshteinDistance
0464:     {
0465:         protected int distance;
0466:         public LevenshteinDistance()
0467:         {
0468:             distance = 0;
0469:         }
0470:         public int Calculate(string a, string b)
0471:         {
0472:             int cost;
0473:             // if a or b has no length, return the other one
0474:             if (a.Length == 0)
0475:             {
0476:                 return b.Length;
0477:             }
0478:             else if (b.Length == 0)
0479:             {
0480:                 return a.Length;
0481:             }
0482:             // row and column sizes are (word.Length + 1) because row/column 1 store index values
0483:             int[,] matrix = new int[a.Length + 1, b.Length + 1];
0484:             // store index values in row/coilumn 1, example
0485:             // 0 1 ...
0486:             // 1
0487:             // 2
0488:             // ...
0489:             for (int c = 0; c < matrix.GetLength(0); c++)
0490:             {
0491:                 matrix[c, 0] = c;
0492:                 for (int d = 0; d < matrix.GetLength(1); d++)
0493:                 {
0494:                     matrix[0, d] = d;
0495:                 }
0496:             }
0497:             for (int c = 1; c < matrix.GetLength(0); c++)
0498:             {
0499:                 for (int d = 1; d < matrix.GetLength(1); d++)
0500:                 {
0501:                     // if the values at the index are the same then no change is needed
0502:                     if (a[c - 1] == b[d - 1])
0503:                     {
0504:                         cost = 0;
0505:                     }
0506:                     // if not then a change (substitution, deletion or addition) is needed
0507:                     else
0508:                     {
0509:                         cost = 1;
0510:                     }
0511:                     int value1 = matrix[c - 1, d] + 1;
0512:                     int value2 = matrix[c, d - 1] + 1;
0513:                     int value3 = matrix[c - 1, d - 1] + cost;
0514:                     int[] values = { value1, value2, value3 };
0515:                     matrix[c, d] = values.Min();
0516:                 }
0517:             }
0518:             // final cost is stored in the bottom right of the matrix
0519:             distance = matrix[a.Length, b.Length];
0520:             return distance;
0521:         }
0522:         public int[] CalculateAll(string a, string[] words)
0523:         {
0524:             int[] distances = new int[words.Length];
0525:             for (int b = 0; b < words.Length; b++)
0526:             {
0527:                 distances[b] = Calculate(a, words[b]);
0528:             }
0529:             return distances;
0530:         }
0531:     }
0532: }
0533: /////////////////
0534: // DefineWords //
0535: /////////////////
0536: namespace DefineWords
0537: {
0538:     // create template to store JSON data retruned by API call
0539:     class Word
0540:     {
0541:         public string? word { get; set; }
0542:         public string? phonetic { get; set; }
0543:         public List<Phonetics>? phonetics { get; set; }
0544:         public List<Meanings>? meanings { get; set; }
0545:         public License? license { get; set; }
0546:         public List<string>? sourceUrls { get; set; }
0547:     }
0548:     class Phonetics
0549:     {
0550:         public string? text { get; set; }
0551:         public string? audio { get; set; }
0552:         public string? sourceUrl { get; set; }
0553:         public License? license { get; set; }
0554:     }
0555:     class License
0556:     {
0557:         public string? name { get; set; }
0558:         public string? url { get; set; }
0559:     }
0560:     class Meanings
0561:     {
0562:         public string? partOfSpeech { get; set; }
0563:         public List<Definitions>? definitions { get; set; }
0564:         public List<string>? synonyms { get; set; }
0565:         public List<string>? antonyms { get; set; }
0566:     }
0567:     class Definitions
0568:     {
0569:         public string? definition { get; set; }
0570:         public List<string>? synonyms { get; set; }
0571:         public List<string>? antonyms { get; set; }
0572:         public string? example { get; set; }
0573:     }
0574:     class Program
0575:     {
0576:         public static List<string> DefineWord(string toDefine)
0577:         {
0578:             WebRequest request = WebRequest.Create("https://api.dictionaryapi.dev/api/v2/entries/en/" + toDefine);
0579:             HttpWebResponse response = (HttpWebResponse)request.GetResponse();
0580:             Stream dataStream = response.GetResponseStream();
0581:             StreamReader reader = new StreamReader(dataStream);
0582:             string responseFromServer = reader.ReadToEnd();
0583:             IEnumerable<Word>? iword = JsonConvert.DeserializeObject<IEnumerable<Word>>(responseFromServer);
0584:             Word[] aword = new List<Word>(iword).ToArray();
0585:             Word word = aword[0];
0586:             // makes sure there is only one definition for each word type
0587:             Dictionary<string, string> definitions = new Dictionary<string, string>()
0588:             {
0589:                 {"noun", "null"},
0590:                 {"pronoun", "null"},
0591:                 {"verb", "null"},
0592:                 {"adjective", "null"},
0593:                 {"adverb", "null"},
0594:                 {"preposition", "null"},
0595:                 {"conjunction", "null"},
0596:                 {"interjection", "null"},
0597:             };
0598:             // if the definition stored for the word type is null, then store the definiton
0599:             for (int a = 0; a < word.meanings.Count; a++)
0600:             {
0601:                 if (definitions[word.meanings[a].partOfSpeech] == "null")
0602:                 {
0603:                     definitions[word.meanings[a].partOfSpeech] = word.meanings[a].definitions[0].definition;
0604:                 }
0605:             }
0606:             // convert values in dictionary to list
0607:             List<string> finals = new List<string>();
0608:             foreach (KeyValuePair<string, string> kvPair in definitions)
0609:             {
0610:                 if (kvPair.Value != "null")
0611:                 {
0612:                     string key = char.ToUpper(kvPair.Key[0]) + kvPair.Key.Substring(1);
0613:                     finals.Add(key + " - " + kvPair.Value);
0614:                 }
0615:             }
0616:             return finals;
0617:         }
0618:         static void Main(string[] args)
0619:         {
0620:             string word = Console.ReadLine();
0621:             List<string> definitions = DefineWord(word);
0622:             foreach (var definition in definitions)
0623:             {
0624:                 Console.WriteLine(definition);
0625:             }
0626:         }
0627:     }
0628: }
0629: Ôªø////////////////
0630: // Program.cs //
0631: ////////////////
0632: // install dependencies
0633: using Views;
0634: using Terminal.Gui;
0635: // suppress warnings
0636: # pragma warning disable
0637: Application.Init();
0638: try
0639: {
0640:     // used to fetch settings from saved file
0641:     Settings thisSettings = new Settings();
0642:     Application.Run(new MainView());
0643: }
0644: finally
0645: {
0646:     Application.Shutdown();
0647: }
0648: ///////////////////////////////////////////
0649: // View designers/MasterView.Designer.cs //
0650: ///////////////////////////////////////////
0651: // install dependencies
0652: using Terminal.Gui;
0653: // suppress warnings
0654: # pragma warning disable
0655: namespace Views
0656: {
0657:     public partial class MasterView : Window
0658:     {
0659:         public void Build()
0660:         {
0661:             Title = "Spell Checker " + this;
0662:             var menuBar = new MenuBar(new MenuBarItem[] {
0663:                 new MenuBarItem("_File", new MenuItem[] {
0664:                     new MenuItem("_Quit", "", () => {
0665:                         Application.Shutdown();
0666:                     }),
0667:                     new MenuItem("_Settings", "", () => {
0668:                         Application.Run(new Settings());
0669:                     }),
0670:                     new MenuItem("_Main View", "", () => {
0671:                         Application.Run(new MainView());
0672:                     }),
0673:                     new MenuItem("_Dictionary", "", () => {
0674:                         Application.Run(new Dictionary());
0675:                     })
0676:                 })
0677:             });
0678:             Add(menuBar);
0679:         }
0680:     }
0681: }
0682: /////////////////////////////////////////
0683: // View designers/Settings.Designer.cs //
0684: /////////////////////////////////////////
0685: // install dependencies
0686: using Terminal.Gui;
0687: // suppress warnings
0688: # pragma warning disable
0689: namespace Views
0690: {
0691:     public partial class Settings : MasterView
0692:     {
0693:         protected Button viewDictBtn = new Button();
0694:         protected Button saveBtn = new Button();
0695:         protected Button resetBtn = new Button();
0696:         protected Button acronymBtn = new Button();
0697:         protected CheckBox spellCheckCbx = new CheckBox();
0698:         protected CheckBox changeAcronymsCbx = new CheckBox();
0699:         protected CheckBox grammarCheckCbx = new CheckBox();
0700:         protected ColorPicker backgroundPick = new ColorPicker();
0701:         protected ColorPicker foregroundPick = new ColorPicker();
0702:         protected Label spellCheckLab = new Label();
0703:         protected Label viewDictLab = new Label();
0704:         protected Label maxLengthLab = new Label();
0705:         protected Label changeAcryonymsLab = new Label();
0706:         protected Label grammarCheckLab = new Label();
0707:         protected Label shortAcrLab = new Label();
0708:         protected Label fullAcrLab = new Label();
0709:         protected TextField maxLengthTxt = new TextField();
0710:         protected TextField shortAcrTxt = new TextField();
0711:         protected TextField fullAcrTxt = new TextField();
0712:         protected void InitializeComponent()
0713:         {
0714:             // build labels
0715:             spellCheckLab.Text = "Spell check";
0716:             spellCheckLab.X = 2;
0717:             spellCheckLab.Y = 2;
0718:             viewDictLab.Text = "View dictionary";
0719:             viewDictLab.X = spellCheckLab.X;
0720:             viewDictLab.Y = spellCheckLab.Y + 2;
0721:             maxLengthLab.Text = "Maximum length                For no max length, enter \"0\"";
0722:             maxLengthLab.X = spellCheckLab.X;
0723:             maxLengthLab.Y = viewDictLab.Y + 2;
0724:             changeAcryonymsLab.Text = "Change acronyms";
0725:             changeAcryonymsLab.X = spellCheckLab.X;
0726:             changeAcryonymsLab.Y = maxLengthLab.Y + 2;
0727:             grammarCheckLab.Text = "Grammar check";
0728:             grammarCheckLab.X = spellCheckLab.X;
0729:             grammarCheckLab.Y = changeAcryonymsLab.Y + 2;
0730:             Add(spellCheckLab, viewDictLab, maxLengthLab, changeAcryonymsLab, grammarCheckLab);
0731:             // build check boxes
0732:             spellCheckCbx.X = spellCheckLab.X + 20;
0733:             spellCheckCbx.Y = spellCheckLab.Y;
0734:             spellCheckCbx.Checked = spellCheck;
0735:             changeAcronymsCbx.X = spellCheckCbx.X;
0736:             changeAcronymsCbx.Y = changeAcryonymsLab.Y;
0737:             changeAcronymsCbx.Checked = changeAcronyms;
0738:             grammarCheckCbx.X = spellCheckCbx.X;
0739:             grammarCheckCbx.Y = grammarCheckLab.Y;
0740:             grammarCheckCbx.Checked = grammarCheck;
0741:             Add(spellCheckCbx, changeAcronymsCbx, grammarCheckCbx);
0742:             // build buttons
0743:             viewDictBtn.Text = "View";
0744:             viewDictBtn.X = spellCheckCbx.X;
0745:             viewDictBtn.Y = viewDictLab.Y;
0746:             saveBtn.Text = "_Save";
0747:             saveBtn.X = maxLengthLab.X;
0748:             saveBtn.Y = grammarCheckLab.Y + 2;
0749:             saveBtn.IsDefault = true;
0750:             resetBtn.X = maxLengthLab.X;
0751:             resetBtn.Y = saveBtn.Y + 2;
0752:             resetBtn.Text = "Reset to default settings";
0753:             Add(viewDictBtn, saveBtn, resetBtn);
0754:             // build text fields
0755:             maxLengthTxt.X = spellCheckCbx.X;
0756:             maxLengthTxt.Y = maxLengthLab.Y;
0757:             maxLengthTxt.Width = 8;
0758:             maxLengthTxt.Text = maxLength.ToString();
0759:             Add(maxLengthTxt);
0760:             // build color elements
0761:             backgroundPick.X = maxLengthLab.X;
0762:             backgroundPick.Y = resetBtn.Y + 2;
0763:             backgroundPick.Text = "Background colour";
0764:             backgroundPick.SelectedColor = background;
0765:             foregroundPick.X = 38;
0766:             foregroundPick.Y = backgroundPick.Y;
0767:             foregroundPick.Text = "Foreground colour";
0768:             foregroundPick.SelectedColor = foreground;
0769:             Add(backgroundPick, foregroundPick);
0770:             // build acronym elements
0771:             shortAcrTxt.X = foregroundPick.X;
0772:             shortAcrTxt.Y = grammarCheckLab.Y;
0773:             shortAcrTxt.Width = 8;
0774:             shortAcrLab.X = shortAcrTxt.X + 9;
0775:             shortAcrLab.Y = shortAcrTxt.Y;
0776:             shortAcrLab.Text = "Short acronym";
0777:             fullAcrTxt.X = shortAcrTxt.X;
0778:             fullAcrTxt.Y = shortAcrTxt.Y + 2;
0779:             fullAcrTxt.Width = 8;
0780:             fullAcrLab.X = shortAcrLab.X;
0781:             fullAcrLab.Y = fullAcrTxt.Y;
0782:             fullAcrLab.Text = "Full acronym";
0783:             acronymBtn.X = shortAcrTxt.X;
0784:             acronymBtn.Y = fullAcrTxt.Y + 2;
0785:             acronymBtn.Text = "Add acronym";
0786:             Add(shortAcrTxt, shortAcrLab, fullAcrTxt, fullAcrLab, acronymBtn);
0787:         }
0788:     }
0789: }
0790: /////////////////////////////////////////
0791: // View designers/MainView.Designer.cs //
0792: /////////////////////////////////////////
0793: // install dependencies
0794: using Terminal.Gui;
0795: // suppress warnings
0796: # pragma warning disable
0797: namespace Views
0798: {
0799:     public partial class MainView : MasterView
0800:     {
0801:         protected Button spellBtn = new Button();
0802:         protected Button clearBtn = new Button();
0803:         protected Label lengthLab = new Label();
0804:         protected TextView textEntry = new TextView();
0805:         protected void InitializeComponent()
0806:         {
0807:             //
0808:             textEntry.X = 1;
0809:             textEntry.Y = 2;
0810:             textEntry.Width = 76;
0811:             textEntry.Height = 15;
0812:             textEntry.WordWrap = true;
0813:             Add(textEntry);
0814:             //
0815:             spellBtn.Text = "Spell check";
0816:             spellBtn.X = 1;
0817:             spellBtn.Y = 20;
0818:             clearBtn.Text = "Clear text";
0819:             clearBtn.X = spellBtn.X + spellBtn.Text.Length + 6;
0820:             clearBtn.Y = spellBtn.Y;
0821:             Add(spellBtn, clearBtn);
0822:         }
0823:     }
0824: }
0825: ///////////////////////////////////////////
0826: // View designers/Dictionary.Designer.cs //
0827: ///////////////////////////////////////////
0828: // install dependencies
0829: using Terminal.Gui;
0830: using NStack;
0831: // suppress warnings
0832: # pragma warning disable
0833: namespace Views
0834: {
0835:     public partial class Dictionary : MasterView
0836:     {
0837:         protected Button lookupBtn = new Button();
0838:         protected Button nextBtn = new Button();
0839:         protected Button prevBtn = new Button();
0840:         protected Button defineBtn = new Button();
0841:         protected Button addBtn = new Button();
0842:         protected Button removeBtn = new Button();
0843:         protected Button filterBtn = new Button();
0844:         protected Label[] wordLabs = new Label[101988];
0845:         protected RadioGroup filterRad = new RadioGroup();
0846:         protected TextField lookupTxt = new TextField();
0847:         protected void InitializeComponent()
0848:         {
0849:             // build lookup elements 
0850:             lookupTxt.X = 50;
0851:             lookupTxt.Y = 4;
0852:             lookupTxt.Width = 14;
0853:             lookupBtn.Text = "Lookup";
0854:             lookupBtn.X = lookupTxt.X;
0855:             lookupBtn.Y = lookupTxt.Y + 2;
0856:             Add(lookupBtn, lookupTxt);
0857:             // build navigation elements
0858:             nextBtn.Text = "Next page";
0859:             nextBtn.X = 64;
0860:             nextBtn.Y = 21;
0861:             prevBtn.Text = "Prev page";
0862:             prevBtn.X = nextBtn.X - 14;
0863:             prevBtn.Y = nextBtn.Y;
0864:             Add(prevBtn, nextBtn);
0865:             // build functional buttons
0866:             defineBtn.X = lookupTxt.X;
0867:             defineBtn.Y = lookupBtn.Y + 2;
0868:             defineBtn.Text = "Define word";
0869:             addBtn.X = lookupTxt.X;
0870:             addBtn.Y = defineBtn.Y + 2;
0871:             addBtn.Text = "Add word";
0872:             removeBtn.X = lookupTxt.X;
0873:             removeBtn.Y = addBtn.Y + 2;
0874:             removeBtn.Text = "Remove word";
0875:             Add(defineBtn, addBtn, removeBtn);
0876:             // build fitering elements
0877:             filterRad.X = lookupTxt.X;
0878:             filterRad.Y = removeBtn.Y + 2;
0879:             filterRad.RadioLabels = new ustring[] { "All words", "Default words", "Added words" };
0880:             filterBtn.X = lookupTxt.X;
0881:             filterBtn.Y = filterRad.Y + 4;
0882:             filterBtn.Text = "Filter list";
0883:             Add(filterRad, filterBtn);
0884:         }
0885:     }
0886: }
0887: ///////////////////////////////////////////
0888: // View designers/SpellCheck.Designer.cs //
0889: ///////////////////////////////////////////
0890: // install dependencies
0891: using Terminal.Gui;
0892: // suppress warnings
0893: # pragma warning disable
0894: namespace Views
0895: {
0896:     public partial class SpellCheck : MasterView
0897:     {
0898:         protected Button ignoreBtn = new Button();
0899:         protected Button userBtn = new Button();
0900:         protected Button acronymBtn = new Button();
0901:         protected Button homeBtn = new Button();
0902:         protected Button homeBtn2 = new Button();
0903:         protected Button replaceBtn = new Button();
0904:         protected Button addBtn = new Button();
0905:         protected Button resizeBtn = new Button();
0906:         protected Label lookupLab = new Label();
0907:         protected Label lookupLab2 = new Label();
0908:         protected Label lookupLab3 = new Label();
0909:         protected Label userLab = new Label();
0910:         protected List<Label> wordLabs = new List<Label>();
0911:         protected TextField lookupTxt = new TextField();
0912:         protected TextField userTxt = new TextField();
0913:         protected void InitializeComponent()
0914:         {
0915:             // build lookup elements
0916:             lookupLab.Text = "Enter word from left side";
0917:             lookupLab.X = 50;
0918:             lookupLab.Y = 2;
0919:             lookupLab2.Text = "in the field below.";
0920:             lookupLab2.X = lookupLab.X;
0921:             lookupLab2.Y = lookupLab.Y + 1;
0922:             lookupLab3.Text = "Then handle error";
0923:             lookupLab3.X = lookupLab.X;
0924:             lookupLab3.Y = lookupLab2.Y + 1;
0925:             lookupTxt.X = lookupLab.X;
0926:             lookupTxt.Y = lookupLab3.Y + 1;
0927:             lookupTxt.Width = 14;
0928:             Add(lookupLab, lookupLab2, lookupLab3, lookupTxt, lookupTxt);
0929:             // 
0930:             ignoreBtn.X = lookupLab.X;
0931:             ignoreBtn.Y = lookupTxt.Y + 2;
0932:             ignoreBtn.Text = "Ignore error";
0933:             Add(ignoreBtn);
0934:             // 
0935:             resizeBtn.Text = "Resize text to " + theseSettings.maxLength;
0936:             resizeBtn.X = lookupLab.X;
0937:             resizeBtn.Y = ignoreBtn.Y + 2;
0938:             Add(resizeBtn);
0939:             // build change error elements
0940:             userLab.Text = "Enter new word";
0941:             userLab.X = lookupLab.X;
0942:             userLab.Y = resizeBtn.Y + 2;
0943:             userTxt.X = lookupLab.X;
0944:             userTxt.Y = userLab.Y + 1;
0945:             userTxt.Width = 14;
0946:             userBtn.Text = "Replace";
0947:             userBtn.X = lookupLab.X;
0948:             userBtn.Y = userTxt.Y + 1;
0949:             replaceBtn.Text = "Recommend words";
0950:             replaceBtn.X = lookupLab.X;
0951:             replaceBtn.Y = userBtn.Y + 2;
0952:             Add(userLab, userTxt, userBtn, replaceBtn);
0953:             // 
0954:             acronymBtn.Text = "Replace acronyms";
0955:             acronymBtn.X = lookupLab.X;
0956:             acronymBtn.Y = replaceBtn.Y + 2;
0957:             Add(acronymBtn);
0958:             // 
0959:             addBtn.Text = "Learn spelling";
0960:             addBtn.X = lookupLab.X;
0961:             addBtn.Y = acronymBtn.Y + 2;
0962:             Add(addBtn);
0963:             // 
0964:             homeBtn.Text = "Home";
0965:             homeBtn.X = lookupLab.X;
0966:             homeBtn.Y = addBtn.Y + 2;
0967:             Add(homeBtn);
0968:         }
0969:     }
0970: }
0971: /////////////////////////
0972: // Views/SpellCheck.cs //
0973: /////////////////////////
0974: // install dependencies
0975: using Terminal.Gui;
0976: using Utilities;
0977: using System.Text.RegularExpressions;
0978: using NStack;
0979: // suppress warnings
0980: # pragma warning disable
0981: namespace Views
0982: {
0983:     public partial class SpellCheck
0984:     {
0985:         protected int firstIndex;
0986:         protected string? error;
0987:         protected List<string> falseWords = new List<string>();
0988:         protected List<string> words = new List<string>();
0989:         protected List<string> ignoredWords = new List<string>();
0990:         protected Settings theseSettings = new Settings();
0991:         public SpellCheck(string textIn)
0992:         {
0993:             words.Clear();
0994:             falseWords.Clear();
0995:             words = textIn.Split(' ').ToList();
0996:             InitializeComponent();
0997:             DisplayWords();
0998:             if (falseWords.Count == 0)
0999:             {
1000:                 LeaveMessage();
1001:             }
1002:             else if (falseWords[0] == "")
1003:             {
1004:                 LeaveMessage();
1005:             }
1006:             ignoreBtn.Clicked += () =>
1007:             {
1008:                 error = lookupTxt.Text.ToString();
1009:                 if (error is not null)
1010:                 {
1011:                     ignoredWords.Add(error);
1012:                     MessageBox.Query("Ignored", error + " has been ignored as an erorr", "Ok");
1013:                     DisplayWords();
1014:                 }
1015:             };
1016:             acronymBtn.Clicked += () =>
1017:             {
1018:                 Settings theseSettings = new Settings();
1019:                 if (theseSettings.changeAcronyms)
1020:                 {
1021:                     ReplaceAcronyms();
1022:                     MessageBox.Query("Acronyms replaced", "All acronyms have been replaced", "Ok");
1023:                     DisplayWords();
1024:                 }
1025:             };
1026:             homeBtn.Clicked += () =>
1027:             {
1028:                 GoHome();
1029:             };
1030:             homeBtn2.Clicked += () =>
1031:             {
1032:                 GoHome();
1033:             };
1034:             userBtn.Clicked += () =>
1035:             {
1036:                 error = lookupTxt.Text.ToString();
1037:                 string newWord = userTxt.Text.ToString();
1038:                 if (newWord is not null)
1039:                 {
1040:                     ReplaceUserWord(newWord);
1041:                 }
1042:                 MessageBox.Query("Replaced", error + " has been replaced to " + newWord, "Ok");
1043:                 DisplayWords();
1044:             };
1045:             replaceBtn.Clicked += () =>
1046:             {
1047:                 error = lookupTxt.Text.ToString();
1048:                 string newWord = "";
1049:                 int maxWeight = 1;
1050:                 bool loop = true;
1051:                 string text;
1052:                 if (error is not null && falseWords.Contains(error))
1053:                 {
1054:                     BkTree bktree = new BkTree(error);
1055:                     do
1056:                     {
1057:                         string[] stringButtons = bktree.ReturnClosest(maxWeight);
1058:                         ustring[] buttons = new ustring[stringButtons.Length + 1];
1059:                         text = "";
1060:                         for (int a = 0; a < stringButtons.Length; a++)
1061:                         {
1062:                             buttons[a] = (a + 1).ToString();
1063:                             text += (a + 1) + ": " + stringButtons[a] + "   ";
1064:                         }
1065:                         text += "\nPress escape to exit";
1066:                         buttons[buttons.Length - 1] = "More words";
1067:                         int choice = MessageBox.Query("Recommended words: " + buttons.Length, text, buttons);
1068:                         if (choice == -1)
1069:                         {
1070:                             return;
1071:                         }
1072:                         else if (choice == buttons.Length - 1)
1073:                         {
1074:                             maxWeight++;
1075:                         }
1076:                         else
1077:                         {
1078:                             newWord = stringButtons[choice];
1079:                             words[words.IndexOf(error)] = newWord;
1080:                             falseWords.Remove(error);
1081:                             loop = false;
1082:                             MessageBox.Query("Replaced", error + " has been replaced to " + newWord, "Ok");
1083:                         }
1084:                     } while (loop);
1085:                 }
1086:                 else if (!falseWords.Contains(error))
1087:                 {
1088:                     MessageBox.ErrorQuery("Error", error + " is not in the false words list\nMake sure it is spelt correctly and in the list", "Ok");
1089:                 }
1090:                 DisplayWords();
1091:             };
1092:             addBtn.Clicked += () =>
1093:             {
1094:                 error = lookupTxt.Text.ToString();
1095:                 using (StreamWriter writer = new StreamWriter("Resources/AddedWords.txt"))
1096:                 {
1097:                     writer.Write(error + "\n");
1098:                 }
1099:                 MessageBox.Query("Spelling learnt", "The spelling of " + error + " has been learnt", "Ok");
1100:                 DisplayWords();
1101:             };
1102:             resizeBtn.Clicked += () =>
1103:             {
1104:                 ResizeText();
1105:                 MessageBox.Query("Text resized", "Text has been resized to " + theseSettings.maxLength, "Ok");
1106:                 DisplayWords();
1107:             };
1108:         }
1109:         protected void CheckSpelling()
1110:         {
1111:             Utilities.BloomFilter bloom = new Utilities.BloomFilter();
1112:             falseWords.Clear();
1113:             // check all words in the bloom filter 
1114:             if (words.Count != 0)
1115:             {
1116:                 for (int a = 0; a < words.Count; a++)
1117:                 {
1118:                     if (!bloom.Lookup(words[a]))
1119:                     {
1120:                         falseWords.Add(words[a]);
1121:                     }
1122:                 }
1123:             }
1124:             if (falseWords.Count != 0)
1125:             {
1126:                 // check all wrong words in the text file of added words 
1127:                 foreach (var a in falseWords)
1128:                 {
1129:                     if (bloom.BinarySearch(a))
1130:                     {
1131:                         falseWords.Remove(a);
1132:                     }
1133:                 }
1134:                 // check all wrong words againt the array of ignored words
1135:                 for (int a = 0; a < falseWords.Count; a++)
1136:                 {
1137:                     for (int b = 0; b < ignoredWords.Count; b++)
1138:                     {
1139:                         if (falseWords[a] == ignoredWords[b])
1140:                         {
1141:                             falseWords.Remove(ignoredWords[b]);
1142:                         }
1143:                     }
1144:                 }
1145:             }
1146:         }
1147:         protected void CheckGrammar()
1148:         {
1149:             int a = 0;
1150:             while (a < words.Count)
1151:             {
1152:                 string word = words[a];
1153:                 Match match = Regex.Match(word, @"[^\w\s]");
1154:                 // if a word contains a special character
1155:                 if (match.Success && word.Length != 1 && match.Value != "'")
1156:                 {
1157:                     string specialChar = word[match.Index].ToString();
1158:                     string part1 = "";
1159:                     string part2 = "";
1160:                     // checks either side of the special character to ensure it is not null
1161:                     //  then stores the values to new strings 
1162:                     if (word[0] != char.Parse(specialChar))
1163:                     {
1164:                         part1 = word.Substring(0, match.Index);
1165:                     }
1166:                     if (word.IndexOf(specialChar) != (word.Length - 1))
1167:                     {
1168:                         part2 = word.Substring(match.Index + 1);
1169:                     }
1170:                     // creates a sub list
1171:                     List<string> postWords = new List<string>();
1172:                     if (match.Index != (words.Count - 1))
1173:                     {
1174:                         postWords = words.GetRange(a + 1, words.Count - a - 1);
1175:                     }
1176:                     // removes all words after & including special character 
1177:                     words.RemoveRange(a, words.Count - a);
1178:                     // adds the parts containing & including special character
1179:                     if (part1 is not null)
1180:                     {
1181:                         words.Add(part1);
1182:                     }
1183:                     words.Add(specialChar);
1184:                     if (part2 is not null)
1185:                     {
1186:                         words.Add(part2);
1187:                     }
1188:                     // concats both lists together
1189:                     words.AddRange(postWords);
1190:                     a += 2;
1191:                 }
1192:                 a++;
1193:             }
1194:             falseWords.RemoveAll(item => string.IsNullOrWhiteSpace(item));
1195:             for (int b = 0; b < falseWords.Count; b++)
1196:             {
1197:                 Match match = Regex.Match(falseWords[b], @"[^\w]");
1198:                 if (match.Success)
1199:                 {
1200:                     falseWords.Remove(falseWords[b]);
1201:                 }
1202:             }
1203:         }
1204:         protected void LeaveMessage()
1205:         {
1206:             RemoveAll();
1207:             Label message1 = new Label();
1208:             message1.Text = "Spell check complete";
1209:             message1.X = Pos.Center();
1210:             message1.Y = Pos.Center() - 1;
1211:             Label message2 = new Label();
1212:             message2.Text = "No errors found".PadLeft(message1.Text.ToString().Length / 2);
1213:             message2.X = message1.X;
1214:             message2.Y = message1.Y + 1;
1215:             homeBtn.Text = "Home";
1216:             homeBtn.X = message1.X;
1217:             homeBtn.Y = message2.Y + 2;
1218:             Add(message1, message2, homeBtn);
1219:         }
1220:         protected void DisplayWords()
1221:         {
1222:             // move any special characters to own index
1223:             CheckGrammar();
1224:             // find false words 
1225:             if (theseSettings.spellCheck)
1226:             {
1227:                 CheckSpelling();
1228:                 CheckGrammar();
1229:             }
1230:             if (falseWords.Count == 0)
1231:             {
1232:                 LeaveMessage();
1233:             }
1234:             else if (falseWords[0] == "")
1235:             {
1236:                 LeaveMessage();
1237:             }
1238:             int xPos = 2;
1239:             int yPos = 2;
1240:             int thisIndex = firstIndex;
1241:             foreach (var a in wordLabs)
1242:             {
1243:                 Remove(a);
1244:             }
1245:             wordLabs.Clear();
1246:             for (int a = 0; a < 41; a++)
1247:             {
1248:                 if (thisIndex < falseWords.Count && ignoredWords.Contains(falseWords[thisIndex]) == false)
1249:                 {
1250:                     wordLabs.Add(new Label());
1251:                     wordLabs[a] = new Label();
1252:                     wordLabs[a].X = xPos;
1253:                     wordLabs[a].Y = yPos;
1254:                     wordLabs[a].Text = falseWords[thisIndex];
1255:                     Add(wordLabs[a]);
1256:                     yPos++;
1257:                     thisIndex++;
1258:                 }
1259:                 if (yPos == 22)
1260:                 {
1261:                     xPos = 30;
1262:                     yPos = 2;
1263:                 }
1264:             }
1265:         }
1266:         protected void ReplaceAcronyms()
1267:         {
1268:             string path = "Resources/Acronyms.txt";
1269:             string[] acronyms = File.ReadAllLines(path);
1270:             string[] shortAcr = new string[acronyms.Length];
1271:             string[] fullAcr = new string[acronyms.Length];
1272:             for (int a = 0; a < acronyms.Length; a++)
1273:             {
1274:                 string[] parts = acronyms[a].Split('*', 2);
1275:                 shortAcr[a] = parts[0];
1276:                 fullAcr[a] = parts[1];
1277:             }
1278:             for (int a = 0; a < falseWords.Count; a++)
1279:             {
1280:                 for (int b = 0; b < acronyms.Length; b++)
1281:                 {
1282:                     if (falseWords[a] == shortAcr[b])
1283:                     {
1284:                         falseWords[a] = fullAcr[b];
1285:                         int index = words.IndexOf(shortAcr[b]);
1286:                         words[index] = falseWords[a];
1287:                     }
1288:                 }
1289:             }
1290:         }
1291:         protected void ReplaceUserWord(string newWord)
1292:         {
1293:             int index = falseWords.IndexOf(error);
1294:             if (index != -1)
1295:             {
1296:                 falseWords[index] = newWord;
1297:                 words[index] = newWord;
1298:             }
1299:         }
1300:         protected void ResizeText()
1301:         {
1302:             string text = "";
1303:             foreach (var a in words)
1304:             {
1305:                 text += a + " ";
1306:             }
1307:             if (theseSettings.maxLength != 0)
1308:             {
1309:                 text = text.Substring(0, theseSettings.maxLength);
1310:             }
1311:             words = text.Split(' ').ToList();
1312:         }
1313:         protected void GoHome()
1314:         {
1315:             string text = "";
1316:             foreach (var a in words)
1317:             {
1318:                 text += a + " ";
1319:             }
1320:             text = FixGrammar(text);
1321:             Application.Run(new MainView(text));
1322:         }
1323:         protected string FixGrammar(string text)
1324:         {
1325:             int speechCount = 0;
1326:             for (int a = 0; a < text.Length; a++)
1327:             {
1328:                 switch (text[a])
1329:                 {
1330:                     // need character before and space after
1331:                     case '.':
1332:                     case ',':
1333:                     case '!':
1334:                     case '?':
1335:                     case ':':
1336:                     case ';':
1337:                     case ')':
1338:                         // before
1339:                         if (a != 0)
1340:                         {
1341:                             if (char.IsWhiteSpace(text[a - 1]))
1342:                             {
1343:                                 text = text.Remove(a - 1, 1);
1344:                             }
1345:                         }
1346:                         // after
1347:                         if (a != text.Length - 1)
1348:                         {
1349:                             if (!char.IsWhiteSpace(text[a + 1]))
1350:                             {
1351:                                 string tempText = text.Substring(a + 1);
1352:                                 text = text.Substring(0, a + 1);
1353:                                 text += " ";
1354:                                 text += tempText;
1355:                             }
1356:                         }
1357:                         break;
1358:                     // need character before and after 
1359:                     case '/':
1360:                         // before
1361:                         if (a != 0)
1362:                         {
1363:                             if (char.IsWhiteSpace(text[a - 1]))
1364:                             {
1365:                                 text = text.Remove(a - 1, 1);
1366:                             }
1367:                         }
1368:                         // after 
1369:                         if (a != text.Length - 1)
1370:                         {
1371:                             if (char.IsWhiteSpace(text[a]))
1372:                             {
1373:                                 text = text.Remove(a, 1);
1374:                             }
1375:                         }
1376:                         break;
1377:                     // need space before and character after
1378:                     case '(':
1379:                         // before 
1380:                         if (a != 0)
1381:                         {
1382:                             if (char.IsWhiteSpace(text[a - 1]))
1383:                             {
1384:                                 string tempText = text.Substring(a);
1385:                                 text = text.Substring(0, a - 1);
1386:                                 text += " ";
1387:                                 text += tempText;
1388:                             }
1389:                         }
1390:                         // after 
1391:                         if (a != text.Length - 1)
1392:                         {
1393:                             if (char.IsWhiteSpace(text[a + 1]))
1394:                             {
1395:                                 text = text.Remove(a + 1, 1);
1396:                             }
1397:                         }
1398:                         break;
1399:                 }
1400:             }
1401:             return text;
1402:         }
1403:     }
1404: }
1405: ///////////////////////
1406: // Views/MainView.cs //
1407: ///////////////////////
1408: // install dependencies
1409: using Terminal.Gui;
1410: // suppress warnings
1411: # pragma warning disable
1412: namespace Views
1413: {
1414:     public partial class MainView
1415:     {
1416:         protected int length = 0;
1417:         public MainView()
1418:         {
1419:             BuildAll();
1420:         }
1421:         // used when coming from the spell check view
1422:         // so the text field will have all the corrected words 
1423:         public MainView(string text)
1424:         {
1425:             BuildAll();
1426:             textEntry.Text = text;
1427:         }
1428:         public void BuildAll()
1429:         {
1430:             InitializeComponent();
1431:             spellBtn.Clicked += () =>
1432:             {
1433:                 string text = textEntry.Text.ToString();
1434:                 if (text is null)
1435:                 {
1436:                     MessageBox.Query("Spell check complete", "No incorrect words", "OK");
1437:                 }
1438:                 else
1439:                 {
1440:                     Application.Run(new SpellCheck(text));
1441:                 }
1442:             };
1443:             clearBtn.Clicked += () =>
1444:             {
1445:                 textEntry.Text = "";
1446:             };
1447:         }
1448:     }
1449: }
1450: /////////////////////////
1451: // Views/Dictionary.cs //
1452: /////////////////////////
1453: // install dependencies
1454: using Terminal.Gui;
1455: // suppress warnings
1456: # pragma warning disable
1457: namespace Views
1458: {
1459:     public partial class Dictionary
1460:     {
1461:         public string[] words;
1462:         protected string? currentLookup;
1463:         protected List<string> toDisplay = new List<string>();
1464:         protected int firstIndex;
1465:         protected int currentFilter;
1466:         public Dictionary()
1467:         {
1468:             words = FetchAllWords();
1469:             firstIndex = 0;
1470:             currentFilter = filterRad.SelectedItem;
1471:             UpdateWords();
1472:             InitializeComponent();
1473:             lookupBtn.Clicked += () =>
1474:             {
1475:                 Lookup(0);
1476:             };
1477:             nextBtn.Clicked += () =>
1478:             {
1479:                 NextPage();
1480:             };
1481:             prevBtn.Clicked += () =>
1482:             {
1483:                 PrevPage();
1484:             };
1485:             defineBtn.Clicked += () =>
1486:             {
1487:                 currentLookup = lookupTxt.Text.ToString();
1488:                 if (currentLookup is not null)
1489:                 {
1490:                     DefineThis(currentLookup);
1491:                 }
1492:                 else
1493:                 {
1494:                     MessageBox.ErrorQuery("Error", "There is no word to define\nEnter a value in the lookup field", "Ok");
1495:                 }
1496:             };
1497:             addBtn.Clicked += () =>
1498:             {
1499:                 currentLookup = lookupTxt.Text.ToString();
1500:                 if (currentLookup is not null && !currentLookup.Contains(" "))
1501:                 {
1502:                     AddThis(currentLookup);
1503:                     UpdateWords();
1504:                 }
1505:                 else
1506:                 {
1507:                     MessageBox.ErrorQuery("Error", "There is no word to add to the dictionary\nEnter a value in the lookup field", "Ok");
1508:                 }
1509:             };
1510:             removeBtn.Clicked += () =>
1511:             {
1512:                 currentLookup = lookupTxt.Text.ToString();
1513:                 if (currentLookup is not null)
1514:                 {
1515:                     RemoveThis(currentLookup);
1516:                     UpdateWords();
1517:                 }
1518:                 else
1519:                 {
1520:                     MessageBox.ErrorQuery("Error", "There is no word to remove fomr the dictionary\nEnter a value in the lookup field", "Ok");
1521:                 }
1522:             };
1523:             filterBtn.Clicked += () =>
1524:             {
1525:                 currentFilter = filterRad.SelectedItem;
1526:                 UpdateWords();
1527:             };
1528:         }
1529:         protected string[] FetchAllWords()
1530:         {
1531:             string defPath = "Resources/TrueWords.txt";
1532:             string addedPath = "Resources/AddedWords.txt";
1533:             List<string> words = File.ReadAllLines(defPath).ToList();
1534:             List<string> addedWords = File.ReadAllLines(addedPath).ToList();
1535:             words.AddRange(addedWords);
1536:             words.Sort();
1537:             string[] values = words.ToArray();
1538:             return values;
1539:         }
1540:         protected string[] FetchWords(int num)
1541:         {
1542:             string path;
1543:             if (num == 1)
1544:             {
1545:                 path = "Resources/TrueWords.txt";
1546:             }
1547:             else
1548:             {
1549:                 path = "Resources/AddedWords.txt";
1550:             }
1551:             words = File.ReadAllLines(path);
1552:             return words;
1553:         }
1554:         protected void NextPage()
1555:         {
1556:             firstIndex += 20;
1557:             if ((toDisplay is null && firstIndex > words.Length) || (toDisplay is not null && firstIndex > toDisplay.Count))
1558:             {
1559:                 firstIndex -= 20;
1560:             }
1561:             Lookup(firstIndex);
1562:         }
1563:         protected void PrevPage()
1564:         {
1565:             if (firstIndex != 0)
1566:             {
1567:                 firstIndex = firstIndex - 20;
1568:             }
1569:             Lookup(firstIndex);
1570:         }
1571:         protected void Lookup(int firstIndexIn)
1572:         {
1573:             firstIndex = firstIndexIn;
1574:             currentLookup = lookupTxt.Text.ToString();
1575:             UpdateWords();
1576:         }
1577:         protected void UpdateWords()
1578:         {
1579:             if (currentFilter == 0)
1580:             {
1581:                 FetchAllWords();
1582:             }
1583:             else
1584:             {
1585:                 FetchWords(currentFilter);
1586:             }
1587:             foreach (var a in wordLabs)
1588:             {
1589:                 Remove(a);
1590:             }
1591:             toDisplay.Clear();
1592:             if (currentLookup is null)
1593:             {
1594:                 toDisplay = words.ToList();
1595:             }
1596:             else
1597:             {
1598:                 for (int a = 0; a < words.Length; a++)
1599:                 {
1600:                     if (words[a].StartsWith(currentLookup))
1601:                     {
1602:                         toDisplay.Add(words[a]);
1603:                     }
1604:                 }
1605:             }
1606:             DisplayLabels(toDisplay);
1607:         }
1608:         protected void DisplayLabels(List<string> toDisplay)
1609:         {
1610:             int yPos = 2;
1611:             int count = 0;
1612:             int thisIndex = firstIndex;
1613:             int lastIndex = firstIndex + 20;
1614:             while (thisIndex < lastIndex)
1615:             {
1616:                 if (thisIndex < toDisplay.Count)
1617:                 {
1618:                     wordLabs[count] = new Label();
1619:                     wordLabs[count].X = 2;
1620:                     wordLabs[count].Y = yPos;
1621:                     wordLabs[count].Text = toDisplay[thisIndex];
1622:                     Add(wordLabs[count]);
1623:                 }
1624:                 else
1625:                 {
1626:                     break;
1627:                 }
1628:                 count++;
1629:                 yPos++;
1630:                 thisIndex++;
1631:             }
1632:         }
1633:         protected void DefineThis(string word)
1634:         {
1635:             try
1636:             {
1637:                 List<string> definitions = DefineWords.Program.DefineWord(word);
1638:                 string definitionstring = "";
1639:                 for (int a = 0; a < definitions.Count; a++)
1640:                 {
1641:                     definitionstring += definitions[a];
1642:                     definitionstring += "\n";
1643:                 }
1644:                 MessageBox.Query("Definitions of " + word, definitionstring, "Ok");
1645:             }
1646:             catch (Exception e)
1647:             {
1648:                 MessageBox.ErrorQuery("Error", "Word could not be defined\n" + e.Message, "Ok");
1649:             }
1650:         }
1651:         protected void AddThis(string word)
1652:         {
1653:             string path = "Resources/AddedWords.txt";
1654:             string[] words = File.ReadAllLines(path);
1655:             if (!words.Contains(word))
1656:             {
1657:                 List<string> newWords = new List<string>();
1658:                 newWords = words.ToList();
1659:                 newWords.Add(word);
1660:                 newWords.Sort();
1661:                 string[] toWrite = newWords.ToArray();
1662:                 File.WriteAllLines(path, toWrite);
1663:             }
1664:             MessageBox.Query("Word added", word + " has been added to the dictionary", "Ok");
1665:         }
1666:         protected void RemoveThis(string word)
1667:         {
1668:             string path = "Resources/AddedWords.txt";
1669:             string[] words = File.ReadAllLines(path);
1670:             if (words.Contains(word))
1671:             {
1672:                 List<string> newWords = new List<string>();
1673:                 newWords = words.ToList();
1674:                 newWords.Remove(word);
1675:                 newWords.Sort();
1676:                 string[] toWrite = newWords.ToArray();
1677:                 File.WriteAllLines(path, toWrite);
1678:             }
1679:             MessageBox.Query("Word removed", word + " has been removed from the dictionary", "Ok");
1680:         }
1681:         protected void FilterList(int choice)
1682:         {
1683:             if (choice == 1)
1684:             {
1685:                 string path = "Resources/TrueWords.txt";
1686:                 string[] words = File.ReadAllLines(path);
1687:             }
1688:             if (choice == 2)
1689:             {
1690:                 string path = "Resources/AddedWords.txt";
1691:                 string[] words = File.ReadAllLines(path);
1692:             }
1693:             UpdateWords();
1694:         }
1695:     }
1696: }
1697: /////////////////////////
1698: // Views/MasterView.cs //
1699: /////////////////////////
1700: // install dependencies
1701: // suppress warnings
1702: # pragma warning disable
1703: namespace Views
1704: {
1705:     public partial class MasterView
1706:     {
1707:         public MasterView()
1708:         {
1709:             Build();
1710:         }
1711:     }
1712: }
1713: ///////////////////////
1714: // Views/Settings.cs //
1715: ///////////////////////
1716: // install dependencies
1717: using Terminal.Gui;
1718: // suppress warnings
1719: # pragma warning disable
1720: namespace Views
1721: {
1722:     public partial class Settings
1723:     {
1724:         public bool spellCheck;
1725:         public bool changeAcronyms;
1726:         public bool grammarCheck;
1727:         public int maxLength;
1728:         public Color background;
1729:         public Color foreground;
1730:         public Settings()
1731:         {
1732:             FetchSettings();
1733:             InitializeComponent();
1734:             saveBtn.Clicked += () =>
1735:             {
1736:                 SaveSettings();
1737:             };
1738:             viewDictBtn.Clicked += () =>
1739:             {
1740:                 Application.Run(new Dictionary());
1741:             };
1742:             resetBtn.Clicked += () =>
1743:             {
1744:                 ResetSettings();
1745:             };
1746:             acronymBtn.Clicked += () =>
1747:             {
1748:                 if (shortAcrTxt.Text.ToString().Length != 0 && fullAcrTxt.Text.ToString().Length != 0)
1749:                 {
1750:                     string shortAcr = shortAcrTxt.Text.ToString();
1751:                     string fullAcr = fullAcrTxt.Text.ToString();
1752:                     AddAcronym(shortAcr, fullAcr);
1753:                     MessageBox.Query("Acronym added", shortAcr + " added as " + fullAcr, "Ok");
1754:                 }
1755:                 else
1756:                 {
1757:                     MessageBox.ErrorQuery("Error", "Enter text in both short and full acronym fields", "Ok");
1758:                 }
1759:             };
1760:         }
1761:         protected void SaveSettings()
1762:         {
1763:             spellCheck = spellCheckCbx.Checked;
1764:             changeAcronyms = changeAcronymsCbx.Checked;
1765:             grammarCheck = grammarCheckCbx.Checked;
1766:             if (!int.TryParse(maxLengthTxt.Text.ToString(), out maxLength))
1767:             {
1768:                 MessageBox.ErrorQuery("Error", "The input for max length must be a whole number\nFor no max length, enter 0", "Ok");
1769:                 return;
1770:             }
1771:             string settings = "Spell " + spellCheck + "\n"
1772:                 + "Lengt " + maxLength + "\n"
1773:                 + "Acron " + changeAcronyms + "\n"
1774:                 + "Grama " + grammarCheck + "\n"
1775:                 + "Foreg " + foregroundPick.SelectedColor + "\n"
1776:                 + "Backg " + backgroundPick.SelectedColor + "\n"
1777:                 ;
1778:             string path = "Resources/Settings.txt";
1779:             File.WriteAllText(path, settings);
1780:             FetchSettings();
1781:             MessageBox.Query("Saved", "Settings saved successfully", "Ok");
1782:         }
1783:         public void FetchSettings()
1784:         {
1785:             string path = "Resources/Settings.txt";
1786:             string[] settings = File.ReadAllLines(path);
1787:             spellCheck = bool.Parse(settings[0].Substring(6));
1788:             maxLength = int.Parse(settings[1].Substring(6));
1789:             changeAcronyms = bool.Parse(settings[2].Substring(6));
1790:             grammarCheck = bool.Parse(settings[3].Substring(6));
1791:             foreground = GetColour(settings[4].Substring(6));
1792:             background = GetColour(settings[5].Substring(6));
1793:             Colors.Base.Normal = Application.Driver.MakeAttribute(foreground, background);
1794:         }
1795:         protected void ResetSettings()
1796:         {
1797:             spellCheck = true;
1798:             maxLength = 0;
1799:             changeAcronyms = true;
1800:             grammarCheck = false;
1801:             foreground = Color.Gray;
1802:             background = Color.Blue;
1803:             string settings = "Spell " + spellCheck + "\n"
1804:                 + "Lengt " + maxLength + "\n"
1805:                 + "Acron " + changeAcronyms + "\n"
1806:                 + "Grama " + grammarCheck + "\n"
1807:                 + "Foreg " + foreground + "\n"
1808:                 + "Backg " + background + "\n"
1809:                 ;
1810:             string path = "Resources/Settings.txt";
1811:             File.WriteAllText(path, settings);
1812:             FetchSettings();
1813:             MessageBox.Query("Reset", "Settings reset to default successfully", "Ok");
1814:         }
1815:         protected void AddAcronym(string shortAcr, string fullAcr)
1816:         {
1817:             string path = "Resources/Acronyms.txt";
1818:             string text = shortAcr + "*" + fullAcr + "\n";
1819:             File.AppendAllText(path, text);
1820:         }
1821:         protected Color GetColour(string colourStr)
1822:         {
1823:             switch (colourStr)
1824:             {
1825:                 case "Black":
1826:                     return Color.Black;
1827:                 case "Blue":
1828:                     return Color.Blue;
1829:                 case "BrightBlue":
1830:                     return Color.BrightBlue;
1831:                 case "BrightCyan":
1832:                     return Color.BrightCyan;
1833:                 case "BrightGreen":
1834:                     return Color.BrightGreen;
1835:                 case "BrightMagenta":
1836:                     return Color.BrightMagenta;
1837:                 case "BrightRed":
1838:                     return Color.BrightRed;
1839:                 case "BrightYellow":
1840:                     return Color.BrightYellow;
1841:                 case "Brown":
1842:                     return Color.Brown;
1843:                 case "Cyan":
1844:                     return Color.Cyan;
1845:                 case "DarkGray":
1846:                     return Color.DarkGray;
1847:                 case "Gray":
1848:                     return Color.Gray;
1849:                 case "Green":
1850:                     return Color.Green;
1851:                 case "Magenta":
1852:                     return Color.Magenta;
1853:                 case "Red":
1854:                     return Color.Red;
1855:                 case "White":
1856:                     return Color.White;
1857:             }
1858:             return Color.Black;
1859:         }
1860:     }
1861: }